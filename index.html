<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カメラ監視ビューア (プロキシ接続対応)</title>
    <!-- Tailwind CSS をロード -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .image-container {
            width: 100%;
            height: 180px; /* 画像の縦横比を考慮した固定高さ */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f3f4f6;
            border-radius: 8px;
            overflow: hidden;
        }
        .camera-image {
            width: 100%;
            height: 100%;
            object-fit: contain; /* 画像全体を表示し、枠に合わせる */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6">カメラライブビューア</h1>

        <!-- CSV フォーマット説明エリア -->
        <div class="bg-white p-4 border border-gray-200 rounded-xl shadow-md mb-6">
            <p class="text-sm font-semibold text-gray-700 mb-2">CSVフォーマット: **URL**,"**カメラ名**","**ID**","**PASS**"</p>
            <p class="text-xs text-gray-500">例: http://192.168.1.1/cgi/Entrance.user,pass123,Entrance,user,pass123</p>
        </div>

        <!-- コントロールパネル -->
        <div class="flex flex-wrap items-center space-y-4 md:space-y-0 md:space-x-4 mb-8">
            <input type="file" id="csvFile" accept=".csv" class="hidden" onchange="displayFileName(this)">
            
            <button onclick="document.getElementById('csvFile').click()" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg hover:bg-gray-600 transition duration-150 shadow-md">
                ファイルを選択
                <span id="fileNameDisplay" class="ml-2 text-sm text-gray-200">未選択</span>
            </button>
            
            <button onclick="handleCsvUpload()" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                CSVを読み込む
            </button>
            
            <span id="cameraCount" class="text-lg font-bold text-orange-600 ml-4">カメラ 0台を登録しました</span>

            <div class="flex space-x-2 ml-auto">
                <button id="refreshButton" onclick="fetchImages()" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
                    全ての画像を再取得
                </button>
                <button onclick="alert('PDF保存機能は未実装です。')" class="px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition duration-150 shadow-md">
                    PDFとして保存
                </button>
            </div>
        </div>

        <!-- 取得結果ステータス -->
        <div class="mb-6">
            <span id="fetchStatus" class="text-lg font-semibold text-gray-700">取得完了。成功: 0件 / 全体: 0件</span>
        </div>

        <!-- カメラグリッド -->
        <div id="cameraGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            <!-- カメラカードがここに動的に挿入されます -->
        </div>

    </div>

    <script>
        let cameras = [];
        const PROXY_BASE_URL = 'https://toracame-proxy.onrender.com/proxy'; 

        // ==============================================
        // CSV 処理ロジック
        // ==============================================

        function displayFileName(input) {
            const display = document.getElementById('fileNameDisplay');
            display.textContent = input.files[0] ? input.files[0].name : '未選択';
        }

        /**
         * CSVテキストをパースしてカメラオブジェクトの配列を返す
         * @param {string} text CSVデータ（ヘッダー行を含む可能性あり）
         * @returns {Array<Object>} カメラ情報オブジェクトの配列
         */
        function parseCSV(text) {
            // 改行で分割し、空行を削除
            const lines = text.trim().split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length < 2) return []; // ヘッダーとデータ行が最低1つ必要

            const result = [];
            // ヘッダー行をスキップし、データ行から処理
            // CSVフォーマット: URL,カメラ名,ID,PASS
            for (let i = 1; i < lines.length; i++) {
                // 正規表現で「カンマ,」または「ダブルクォーテーションで囲まれた文字列」を分割
                // この単純なsplit(',')は、カメラ名にカンマが入っていると破綻するため、より堅牢なパースを推奨しますが、
                // 一旦は基本的なカンマ区切りとして処理します。
                const parts = lines[i].split(',');
                
                if (parts.length >= 4) {
                    result.push({
                        url: parts[0].trim(),
                        name: parts[1].trim(),
                        id: parts[2].trim(),
                        password: parts[3].trim(),
                    });
                } else {
                    console.warn(`CSVパース警告: 行 ${i + 1} は不正な形式です。スキップしました: ${lines[i]}`);
                }
            }
            return result;
        }

        function handleCsvUpload() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('CSVファイルを選択してください。');
                return;
            }

            const reader = new FileReader();
            
            // ファイルの読み込みが成功した時の処理
            reader.onload = (e) => {
                try {
                    const csvText = e.target.result;
                    cameras = parseCSV(csvText);

                    // ログ: 読み込み成功とカメラ台数
                    console.log(`CSVファイルを正常に読み込みました。カメラ ${cameras.length}台を検出。`);

                    if (cameras.length === 0) {
                        document.getElementById('cameraCount').textContent = 'カメラ 0台を登録しました (データ不正の可能性あり)';
                        console.error('CSVファイルに有効なカメラデータが見つかりませんでした。ヘッダーとデータ行を確認してください。');
                        renderCameras(); // ゼロ件としてレンダリングを試みる
                        return;
                    }

                    document.getElementById('cameraCount').textContent = `カメラ ${cameras.length}台を登録しました`;
                    renderCameras();

                } catch (error) {
                    console.error('CSV読み込み処理中に重大なエラーが発生しました:', error);
                    // ユーザーフレンドリーなメッセージも表示
                    document.getElementById('fetchStatus').textContent = `エラー：CSV処理失敗。コンソールを確認してください。`;
                }
            };

            // ファイルの読み込みが失敗した時の処理（主にエンコーディング関連）
            reader.onerror = (error) => {
                console.error('FileReaderエラー: ファイルの読み込みに失敗しました。', error);
                document.getElementById('fetchStatus').textContent = `エラー：ファイルの読み込みに失敗しました。エンコーディングを確認してください。`;
            };

            // 日本語のCSVファイルを想定し、Shift_JISで読み込み
            // Shift_JIS で失敗する場合は 'utf-8' も試す必要があります。
            // ひとまず Shift_JIS で確定。
            reader.readAsText(file, 'Shift_JIS'); 
        }

        // ==============================================
        // UI レンダリングロジック
        // ==============================================

        function renderCameras() {
            const grid = document.getElementById('cameraGrid');
            grid.innerHTML = ''; // カメラグリッドをクリア

            if (cameras.length === 0) {
                grid.innerHTML = '<p class="text-gray-500 col-span-4">CSVを読み込んでカメラを登録してください。</p>';
                document.getElementById('fetchStatus').textContent = '取得完了。成功: 0件 / 全体: 0件';
                return;
            }

            cameras.forEach((camera, index) => {
                const cameraCard = document.createElement('div');
                cameraCard.className = 'bg-white shadow-lg rounded-xl p-4 transition duration-200 hover:shadow-xl';
                cameraCard.innerHTML = `
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">${index + 1}. ${camera.name}</h3>
                    <div class="image-container">
                        <img id="image-${index}" class="camera-image" src="https://placehold.co/100x100/eeeeee/000000?text=未取得" alt="${camera.name}画像">
                    </div>
                    <p id="status-${index}" class="mt-3 text-center font-bold text-gray-500">未取得</p>
                `;
                grid.appendChild(cameraCard);
            });

            // ロード後、すぐに画像取得を開始
            fetchImages();
        }
        
        // ==============================================
        // ヘルパー関数: 画像ロードとメモリ解放
        // ==============================================
        function attemptImageLoad(imageElement, buffer, index) {
            return new Promise((resolve, reject) => {
                const blob = new Blob([buffer], { type: 'image/jpeg' });
                const imageUrl = URL.createObjectURL(blob);
                
                // 成功した場合
                imageElement.onload = () => {
                    URL.revokeObjectURL(imageUrl); // メモリ解放
                    resolve(true);
                };
                // 失敗した場合 (データが不正でブラウザがデコードできなかった場合)
                imageElement.onerror = () => {
                    URL.revokeObjectURL(imageUrl); // メモリ解放
                    reject(new Error('画像デコード失敗 (不正なデータ構造)'));
                };
                
                // 画像ソースを設定し、ロードを開始
                imageElement.src = imageUrl;
            });
        }


        // ==============================================
        // 最終最終調整版: 画像取得とデータクリーニングロジック
        // ==============================================
        async function fetchSingleImage(camera, index) {
            const statusElement = document.getElementById(`status-${index}`);
            const imageElement = document.getElementById(`image-${index}`);
            
            // UIをリセット
            statusElement.textContent = '取得中...';
            statusElement.className = 'mt-3 text-center font-bold text-gray-500';
            imageElement.src = 'https://placehold.co/100x100/eeeeee/000000?text=Loading';

            const MAX_RETRIES = 5; 
            const RETRY_DELAY_MS = 1500; 
            const MIN_IMAGE_SIZE = 500; 
            let lastError = null;

            // コンソールログ開始
            console.log(`カメラ ${index + 1}: ${camera.name} の画像取得を開始...`);

            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                try {
                    // キャッシュバスターとプロキシURLの構築
                    const cacheBuster = `&_ts=${Date.now()}`;
                    const proxyUrl = `${PROXY_BASE_URL}?url=${encodeURIComponent(camera.url)}&id=${encodeURIComponent(camera.id)}&password=${encodeURIComponent(camera.password)}${cacheBuster}`;
                    
                    const response = await fetch(proxyUrl);

                    if (response.ok) {
                        const buffer = await response.arrayBuffer();
                        let cleanedBuffer = buffer; // クリーニング前のオリジナルバッファ

                        // データのサイズチェック
                        if (buffer.byteLength < MIN_IMAGE_SIZE) {
                            lastError = `画像データが小さすぎます (${buffer.byteLength} bytes)。`;
                            console.warn(`カメラ ${index + 1}: ${lastError} リトライ実行`);
                            
                            if (attempt < MAX_RETRIES) {
                                statusElement.textContent = `不完全データ。リトライ中 (${attempt}/${MAX_RETRIES})...`;
                                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
                                continue; 
                            }
                        }

                        // ロード試行とデータクリーニング
                        try {
                            await attemptImageLoad(imageElement, buffer, index);
                            
                            // 1. クリーンアップなしで成功した場合
                            statusElement.textContent = 'OK';
                            statusElement.className = 'mt-3 text-center font-bold text-green-600';
                            console.log(`カメラ ${index + 1}: 取得成功 (試行 ${attempt}回目), サイズ: ${buffer.byteLength} bytes`);
                            return { success: true, camera: camera.name };

                        } catch (loadError) {
                            // 2. クリーンアップなしでデコード失敗した場合
                            if (loadError.message === '画像デコード失敗 (不正なデータ構造)' && attempt < MAX_RETRIES) {
                                console.warn(`カメラ ${index + 1}: デコード失敗。データクリーニングを試みます...`);
                                
                                // JPEGマジックバイト (0xFF, 0xD8) を探すロジック
                                const dataView = new DataView(buffer);
                                let skipBytes = 0;
                                while (skipBytes < buffer.byteLength - 1) {
                                    // 最初の 0xFFD8 を探す
                                    if (dataView.getUint8(skipBytes) === 0xFF && dataView.getUint8(skipBytes + 1) === 0xD8) {
                                        break; 
                                    }
                                    skipBytes++;
                                }

                                if (skipBytes > 0 && skipBytes < buffer.byteLength) {
                                    // 不正なバイトが発見された場合、それらをスキップ
                                    console.log(`カメラ ${index + 1}: 先頭の ${skipBytes} バイトをクリーンアップしました。再ロード試行。`);
                                    cleanedBuffer = buffer.slice(skipBytes);
                                    
                                    // クリーンアップされたバッファで再度ロードを試みる
                                    await attemptImageLoad(imageElement, cleanedBuffer, index);

                                    // 3. クリーンアップ後のロード成功
                                    statusElement.textContent = 'OK (Cleaned)';
                                    statusElement.className = 'mt-3 text-center font-bold text-green-600';
                                    console.log(`カメラ ${index + 1}: クリーンアップ後、取得成功 (試行 ${attempt}回目), サイズ: ${cleanedBuffer.byteLength} bytes`);
                                    return { success: true, camera: camera.name };
                                }
                                
                                // クリーンアップしてもダメだった場合、通常のリトライへ
                                lastError = 'デコード失敗後、データクリーニングも効果なし。';
                                console.error(`カメラ ${index + 1}: ${lastError} 次のリトライへ。`);
                                statusElement.textContent = `デコード失敗。リトライ中 (${attempt}/${MAX_RETRIES})...`;
                                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
                                continue;

                            } else {
                                // その他のロードエラー (MAX_RETRIESに到達したデコード失敗など) は、外側の catch へ
                                throw loadError;
                            }
                        }
                        
                    } else {
                        // サーバーエラー (401, 500など) の処理
                        const errorText = await response.text();
                        lastError = `サーバーエラー: ${response.status} ${response.statusText} (${errorText.substring(0, 50)}...)`;
                        console.error(`カメラ ${index + 1}: 取得失敗 (試行 ${attempt}回目): ${lastError}`);
                        
                        if (attempt < MAX_RETRIES) {
                            statusElement.textContent = `リトライ中 (${attempt}/${MAX_RETRIES})...`;
                            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
                        }
                    }
                } catch (error) {
                    // ネットワークエラー、または画像デコード失敗エラー
                    lastError = `処理失敗: ${error.message}`;
                    console.error(`カメラ ${index + 1}: 処理失敗 (試行 ${attempt}回目):`, error);

                    if (attempt < MAX_RETRIES) {
                        statusElement.textContent = `リトライ中 (${attempt}/${MAX_RETRIES})...`;
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
                    }
                }
            }

            // 全てのリトライが失敗した場合
            statusElement.textContent = `エラー: ${lastError}`;
            statusElement.className = 'mt-3 text-center font-bold text-red-600';
            imageElement.src = 'https://placehold.co/100x100/ffbbbb/800000?text=エラー';
            console.error(`カメラ ${index + 1}: 最終取得失敗`);
            return { success: false, camera: camera.name };
        }

        async function fetchImages() {
            if (cameras.length === 0) {
                alert('カメラが登録されていません。CSVを読み込んでください。');
                return;
            }

            const refreshButton = document.getElementById('refreshButton');
            refreshButton.disabled = true;
            refreshButton.textContent = '取得処理中...';

            const promises = cameras.map((camera, index) => fetchSingleImage(camera, index));
            const results = await Promise.allSettled(promises);

            let successCount = 0;
            results.forEach(result => {
                if (result.status === 'fulfilled' && result.value.success) {
                    successCount++;
                }
            });

            document.getElementById('fetchStatus').textContent = `取得完了。成功: ${successCount}件 / 全体: ${cameras.length}件`;

            refreshButton.disabled = false;
            refreshButton.textContent = '全ての画像を再取得';
        }

        // ページロード時の初期化
        window.onload = () => {
             // 特に初期設定はなし。ユーザーがCSVをアップロードするのを待つ
        };
    </script>
</body>
</html>
